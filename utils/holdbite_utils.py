'''
Functions for HoldBite movies
'''

import numpy as np
import os, sys
from datetime import datetime as dt
import importlib
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib.collections import PatchCollection
from matplotlib.patches import Rectangle
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
import json
import random
import re
from PIL import Image, ImageFont, ImageDraw
import cv2
import dlib
import argparse
import imutils
import time
from imutils.video import VideoStream
import statistics
from pathlib import Path
from cv_utils import *

def json_serial(obj):
    import datetime as dt
    if isinstance(obj, (dt.datetime, dt.date)):
        return obj.isoformat()
    raise TypeError ("Type %s not serializable" % type(obj))

#############################################################################
#
# Load dictionary of movie info from json file
#
# input arguments:
# jsonFile - (string) path to json file containing movie info
#
# return:
# movInfo  - (dict) dictionary containing movie info
#
#############################################################################
def loadData(jsonFile):
    with open(jsonFile,'r') as f:
        jstr = f.read()
    data = json.loads(jstr)
    movInfoRaw = data['movInfo']
    movInfo = nestedSqueeze(movInfoRaw)
    return movInfo

#############################################################################
#
# Save updated movie info to file
#
# input arguments:
# jsonFile - (string) path to json file containing movie info
# key      - (string)
# value    - (string)
#
#############################################################################
def updateMovieInfoFile(jsonFile, key1, value, key2=None):
    with open(jsonFile,'r') as f:
        jstr = f.read()
    movInfo = json.loads(jstr)
    if key2==None:
        movInfo["movInfo"].update({key1:value})
    else:
        movInfo["movInfo"][key1].update({key2:value})

    with open(jsonFile, 'w+') as f:
        f.write(json.dumps(movInfo, 
                           sort_keys=True, indent=2, separators=(',', ': '), 
                           default=json_serial))
        
#############################################################################
#
# Make HoldBite Movie
#
# input arguments:
# movInfo      - (dict) data to make movie (generated by matlab)
# saveToFolder - (string) path to folder where finished movies are saved
#
#############################################################################
def makeHoldBiteMovieLabeled(movInfo, frontLabels, sideLabels, saveToFolder, frontWindow=None, sideWindow=None, codec='MJPG',ext='.avi'):
    plt.close('all')
    if frontWindow==None:
        try:
            frontWindow = tuple(movInfo['FrontMovie']['Window'])
        except:
            frontWindow = (0, 0, 160, 120)
    if sideWindow==None:
        try:
            sideWindow = tuple(movInfo['SideMovie']['Window'])
        except:
            sideWindow = (0, 0, 160, 120)
            
    baseName = os.path.basename(movInfo['SessionFile'])
    sessionStr, jext = os.path.splitext(baseName)
    fullMovPath = os.path.join(saveToFolder, sessionStr + ext)

    hasFront = len(movInfo['FrontMovie']['Folder'])>0
    hasSide = len(movInfo['SideMovie']['Folder'])>0
    hasLog = len(movInfo['BiteTraces']['LogFile'])>0

    if hasFront and hasSide:
        numVids = 2
    elif hasFront ^ hasSide: # either but not both
        numVids = 1
    else:
        raise Exception('Must have at least one video to label.')
        
    hasFrontLabels = (frontLabels!=None)
    hasSideLabels = (sideLabels!=None)
    
    
    bodyPartsColsF = {'leftPupil':(180, 230, 245, 128),
                      'rightPupil':(0, 71, 160, 128),
                      'nose':(36, 211, 154, 128)}
    bodyPartsColsS = {'nose':(36, 211, 154, 128),
                     'tearDuct':(180, 230, 245, 128),
                     'pupil':(205, 2, 43, 128),
                     'backCorner':(0, 71, 160, 128)}

        
    plotHeight = 480
    plotWidth = 640
    him = 240
    wim = 320

    (hf, wf) = (plotHeight, plotWidth+2*wim)

    outputFrame = np.zeros((hf, wf, 3)).astype(np.uint8)
    plotIm = np.zeros((plotHeight, plotWidth, 3)).astype(np.uint8)

    timestampPos = (10, 10)
    bitePos = ()

    fontSize = 20
    axLabelFontSize = 15
    axLabelFontName = 'DejaVu Sans'
    font = {'family' : 'sans-serif',
            'weight' : 'light',
            'size'   : 18}

    mpl.rc('font', **font)
    font = ImageFont.truetype(os.path.join(Path().absolute(), 'Roboto', 'Roboto-Black.ttf'), fontSize)
    timestampCol = (255, 255, 255)
    biteCol = 'forestgreen'
    waterCol = 'darkturquoise'
    timeoutCol = 'crimson'
    
    
    frontImTrace = Image.new('RGB', (frontWindow[2]-frontWindow[0], frontWindow[3]-frontWindow[1]))
    sideImTrace = Image.new('RGB', (sideWindow[2]-sideWindow[0], sideWindow[3]-sideWindow[1]))
    drawObjFTrace = ImageDraw.Draw(frontImTrace)
    drawObjSTrace = ImageDraw.Draw(sideImTrace)
    frontImTraceResized = Image.new('RGB', (wim, him))
    sideImTraceResized = Image.new('RGB', (wim, him))
    drawObjFTraceResized = ImageDraw.Draw(frontImTraceResized)
    drawObjSTraceResized = ImageDraw.Draw(sideImTraceResized)
    yinc = fontSize
    ypos = 0
    if hasFrontLabels:
        prevXYF = {}
        for part in bodyPartsColsF:
            drawObjFTrace.text((0, ypos), part, fill=bodyPartsColsF[part], font=font)
            ypos += yinc
            prevXYF.update({part:{'x':None, 'y':None, 'likelihood':None}})
    ypos = 0
    if hasSideLabels:
        prevXYS = {}
        for part in bodyPartsColsS:
            drawObjSTrace.text((0, ypos), part, fill=bodyPartsColsS[part], font=font)
            ypos += yinc
            prevXYS.update({part:{'x':None, 'y':None, 'likelihood':None}})
            

    # initialize the FourCC, video writer, dimensions of the frame, and
    fourcc = cv2.VideoWriter_fourcc(*codec)
    print('Save to:', fullMovPath)
    writer = cv2.VideoWriter(fullMovPath, fourcc, movInfo['FrameRate'], (wf, hf))

    # make plots
    plotFig, ax = plt.subplots(3,1)#,dpi=200, figsize=(640/200, 480/200))
    canvas = FigureCanvas(plotFig)
    bbox = plotFig.get_window_extent().transformed(plotFig.dpi_scale_trans.inverted())
    width, height = bbox.width, bbox.height
    width *= plotFig.dpi
    height *= plotFig.dpi

    windAx = ax[0]
    fullAx = ax[1]
    avgAx = ax[2]
    
    windAx.tick_params(bottom=False, left=False)
    fullAx.tick_params(bottom=False, left=False)
    avgAx.tick_params(bottom=False, left=False)
    windAx.set_frame_on(False)
    fullAx.set_frame_on(False)
    avgAx.set_frame_on(False)

    windowSize = 20
    biteWindow = 1

    allBiteTimes = movInfo['AllBiteTimes']
    try:
        allBiteDurs = allBiteTimes[:,1] - allBiteTimes[:,0]
    except:
        allBiteDurs = allBiteTimes[1] - allBiteTimes[0]
        allBiteDurs = np.expand_dims(allBiteDurs, axis=0)
        allBiteDurs = allBiteTimes[:,1] - allBiteTimes[:,0]

    avgBiteDur = movmean(allBiteDurs, windowSize)
    rewardTimes = movInfo['RewardTimes']
    if len(rewardTimes.shape)<2:
        rewardTimes = np.expand_dims(rewardTimes, axis=0)
    rewardTimes = np.array(rewardTimes)

    timeoutTimes = movInfo['TimeoutTimes']
    if len(timeoutTimes.shape)<2:
        timeoutTimes = np.expand_dims(timeoutTimes, axis=0)
    timeoutTimes = np.array(timeoutTimes)
    avgAx.set_xlabel('Time (s)', fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    avgAx.set_ylabel('Avg Duration (s)', fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    avgAx.set_xlim(0, movInfo['SessionDuration'])
#

    fullAx.set_ylim(-0.1, 3.1)
    fullAx.set_xlim(0, movInfo['SessionDuration'])
    fullAx.set_yticks([0.5, 1.5, 2.5])
    fullAx.set_yticklabels(['Timeout', 'Water', 'Biting'], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    fullAx.set_xticks([])
    fullAx.set_xticklabels([])

    windAx.set_title(' '.join([movInfo['Subject'], 'HoldTime: %03d ms on' % movInfo['HoldTime'], movInfo['DateString'], 'at', movInfo['TimeString']]))
    windAx.set_ylim(-0.1, 3.1)
    windAx.set_xlim(0, biteWindow)
    windAx.set_yticks([0.5, 1.5, 2.5])
    windAx.set_yticklabels(['Timeout', 'Water', 'Biting'], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')


    biteDurLine = avgAx.plot(allBiteTimes[:,0], avgBiteDur, color='royalblue',
                             linewidth=1, label='Avg Bite Duration (last %d bites)' % windowSize)

    avgAxYLim = avgAx.get_ylim()
    numBites = len(avgBiteDur)
    numRewards = len(avgBiteDur)
    numTimeouts = len(avgBiteDur)

    biteBoxes = []
    timeoutBoxes = []
    waterBoxes = []

    #bite boxes
    for bite in range(numBites):
        biteOn = allBiteTimes[bite,0]
        biteOff = allBiteTimes[bite,1]
        biteDur = biteOff - biteOn
        rect = Rectangle((biteOn,2.1), biteDur, 0.8)
        biteBoxes.append(rect)

    #water boxes
    for reward in rewardTimes:
        rewardOn = reward[0]
        rewardOff = reward[1]
        rewardDur = rewardOff - rewardOn
        rect = Rectangle((rewardOn,1.1), rewardDur, 0.8)
        waterBoxes.append(rect)

    #timeout boxes
    for timeout in timeoutTimes:
        timeoutOn = timeout[0]
        timeoutOff = timeout[1]

        timeoutDur = timeoutOff - timeoutOn
        rect = Rectangle((timeoutOn,0.1), timeoutDur, 0.8)
        timeoutBoxes.append(rect)

    biteCollectionFull = PatchCollection(biteBoxes, facecolor=biteCol, edgecolor='None')
    biteCollectionWind = PatchCollection(biteBoxes, facecolor=biteCol, edgecolor='None')

    waterCollectionFull = PatchCollection(waterBoxes, facecolor=waterCol, edgecolor='None')
    waterCollectionWind = PatchCollection(waterBoxes, facecolor=waterCol, edgecolor='None')

    timeoutCollectionFull = PatchCollection(timeoutBoxes, facecolor=timeoutCol, edgecolor='None')
    timeoutCollectionWind = PatchCollection(timeoutBoxes, facecolor=timeoutCol, edgecolor='None')



    # Add collection to axes
    windAx.add_collection(biteCollectionWind)
    fullAx.add_collection(biteCollectionFull)
    windAx.add_collection(waterCollectionWind)
    fullAx.add_collection(waterCollectionFull)
    windAx.add_collection(timeoutCollectionWind)
    fullAx.add_collection(timeoutCollectionFull)

    if hasLog:
        fullAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Analog']+2, linewidth=0.5, color='gold')
        fullAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Digital']+2, linewidth=0.5, color='mediumpurple')
        windAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Analog']+2, linewidth=2, color='gold', label='Sensor')
        windAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Digital']+2, linewidth=2, color='mediumpurple', label='Bpod')
        windAx.legend( loc='lower right')



    plotFig.set_size_inches( 640/plotFig.dpi, 480/plotFig.dpi)

    canvas.draw()

    labels = avgAx.get_xticklabels(which='major')
    labs = [label.get_text() for label in labels]
    avgAx.set_xticklabels(labs, fontsize=axLabelFontSize, fontweight=1)

    windAx.set_xlim(-0.1, biteWindow+0.1)
    lastBiteIdx = 0
    lcutoffF = 0.2
    lcutoffS = 0.2
    markerRadius = 2


    for fidx, frameTime in enumerate(movInfo['FrameTimes']):
        windAx.set_xlim(frameTime-0.1, frameTime+biteWindow+0.1)

        fullRect = Rectangle((frameTime,0), biteWindow, 3, fill=None, edgecolor='k', linewidth=2)
        fullAx.add_patch(fullRect)

        windRect = Rectangle((frameTime,0), biteWindow, 3, fill=None, edgecolor='k', linewidth=2)
        windAx.add_patch(windRect)
        bdl = '%03d ms' %int(1000*avgBiteDur[lastBiteIdx])
        avl = avgAx.plot([frameTime, frameTime], [0, 1], color='red',linewidth=2,label=bdl)
        avgAx.set_ylim(avgAxYLim)
        avleg = avgAx.legend(loc='lower right', fontsize=axLabelFontSize-2)
        
              
        if allBiteTimes[lastBiteIdx,0]<=frameTime:
            if lastBiteIdx<len(allBiteTimes[:,0])-1:
                lastBiteIdx += 1

        canvas.draw()       # draw the canvas, cache the renderer

        s, (width, height) = canvas.print_to_buffer()
        plotIm = np.fromstring(canvas.tostring_rgb(), dtype='uint8').reshape(height, width, 3)
        avl[0].remove()
        fullRect.remove()
        windRect.remove()
        del avl
        avleg.remove()
        #plotImArr = np.array(plotFig.canvas.renderer.buffer_rgba())
        if fidx==0:
            plt.figure()
            plt.imshow(plotIm)
        #draw biting/water
        biting = movInfo['BiteFrames'][fidx]
        deliveringReward = movInfo['WaterFrames'][fidx]

        if not hasFront:
            frontIm = Image.new('RGB', (frontWindow[2]-frontWindow[0], frontWindow[3]-frontWindow[1]))
            drawObjF = ImageDraw.Draw(frontIm)
        else:
            imfPath = os.path.join(movInfo['FrontMovie']['Folder'],
                                  movInfo['FrontMovie']['ImageNames'][fidx])
            imfGray = Image.open(imfPath)
            imfGray = imfGray.crop(frontWindow)
            imfGray = imfGray.rotate(180)
            frontIm = imfGray.convert('RGB')
            drawObjF = ImageDraw.Draw(frontIm)

            #draw timestamp
            ftf = movInfo['FrontMovie']['Timestamps'][fidx]
            ftfStr = formatTimeStr(ftf)
            textWidth, textHeight = drawObjF.textsize(ftfStr, font=font)
            timestampPos = (wim-textWidth, 0)
            drawObjF.text(timestampPos, ftfStr, fill=timestampCol, font=font)
            
            #draw Labels
            for part in frontLabels:
                x = frontLabels[part]['x'][fidx]
                y = frontLabels[part]['y'][fidx]
                l = frontLabels[part]['likelihood'][fidx]
                ladd = np.log10(l)
                xyF = [int(x-(markerRadius+ladd)), int(y-(markerRadius+ladd)), 
                      int(x+markerRadius+ladd), int(y+(markerRadius+ladd))]
                
                if prevXYF[part]['x'] is None: #part hasn't had a coordinate yet
                    if l>lcutoffF and biting:
                        prevXYF[part].update({'x':int(x), 'y':int(y)})
                else:
                    if l>lcutoffF and biting:
                        xyfline = [prevXYF[part]['x'], prevXYF[part]['y'], int(x), int(y)]
                        drawObjFTrace.line(xyfline, fill=bodyPartsColsF[part], width=1)
                        prevXYF[part].update({'x':int(x), 'y':int(y)})
                    
                if l>lcutoffF:
                    drawObjF.ellipse(xyF,
                                  fill=bodyPartsColsF[part], outline=None)
                    print(np.array(frontImTrace).shape)
                
            

        if not hasSide:
            sideIm = Image.new('RGB', (sideWindow[2]-sideWindow[0], sideWindow[3]-sideWindow[1]))
            drawObjS = ImageDraw.Draw(sideIm)
        else:
            imsPath = os.path.join(movInfo['SideMovie']['Folder'],
                                  movInfo['SideMovie']['ImageNames'][fidx])
            imsGray = Image.open(imsPath)
            imsGray = imsGray.crop(sideWindow)
            imsGray = imsGray.rotate(180)
            sideIm = imsGray.convert('RGB')
            drawObjS = ImageDraw.Draw(sideIm)

            #draw timestamp
            fts = movInfo['SideMovie']['Timestamps'][fidx]
            ftsStr = formatTimeStr(fts)
            textWidth, textHeight = drawObjS.textsize(ftsStr, font=font)
            timestampPos = (wim - textWidth, 0)
            drawObjS.text(timestampPos, ftsStr, fill=timestampCol, font=font)
            
            #draw Labels
            for part in sideLabels:
                x = sideLabels[part]['x'][fidx]
                y = sideLabels[part]['y'][fidx]
                l = sideLabels[part]['likelihood'][fidx]
                ladd = np.log10(l)
                xyS = [int(x-(markerRadius+ladd)), int(y-(markerRadius+ladd)), 
                      int(x+markerRadius+ladd), int(y+(markerRadius+ladd))]
                
                if prevXYS[part]['x'] is None: #part hasn't had a coordinate yet
                    if l>lcutoffS and biting:
                        prevXYS[part].update({'x':int(x), 'y':int(y)})
                else:
                    if l>lcutoffS and biting:
                        xysline = [prevXYS[part]['x'], prevXYS[part]['y'], int(x), int(y)]
                        drawObjSTrace.line(xysline, fill=bodyPartsColsS[part], width=1)
                        prevXYS[part].update({'x':int(x), 'y':int(y)})
                    
                if l>lcutoffS:
                    drawObjS.ellipse(xyS,
                                  fill=bodyPartsColsS[part], outline=None)
                    print(np.array(frontImTrace).shape)

        #draw biting/water
        biting = movInfo['BiteFrames'][fidx]
        deliveringReward = movInfo['WaterFrames'][fidx]
        if biting:
                drawObjF.text((0, 0), 'BITING', fill=biteCol, font=font)
        if deliveringReward:
                drawObjF.text((0, fontSize+1), 'WATER', fil=waterCol, font=font)
        frontIm = frontIm.resize((wim, him))
        frontImTraceResized = frontImTrace.resize((wim, him))
        frontOut = np.array(frontIm).astype(np.uint8)
        sideIm = sideIm.resize((wim, him))
        sideImTraceResized = sideImTrace.resize((wim, him))
        sideOut = np.array(sideIm).astype(np.uint8)
        
        outputFrame[0:hf, 0:plotWidth, :] = np.flip(plotIm,axis=2)
        
        
        outputFrame[0:him, plotWidth:plotWidth+wim, :] = np.flip(frontOut, axis=2)
        outputFrame[him:2*him, plotWidth:plotWidth+wim, :] = np.flip(sideOut, axis=2)
        
        outputFrame[0:him, plotWidth+wim:plotWidth+2*wim, :] = np.flip(frontImTraceResized, axis=2)
        outputFrame[him:2*him, plotWidth+wim:plotWidth+2*wim, :] = np.flip(sideImTraceResized, axis=2)

        cv2.imshow("OutputFrame", outputFrame)
        writer.write(outputFrame)
        # show the frames
        key = cv2.waitKey(30)
        # if the `q` key was pressed, break from the loop
        if key == 27:
            break

    # do a bit of cleanup
    print("[INFO] cleaning up...")
    cv2.destroyAllWindows()
    writer.release()

#############################################################################
#
# Make HoldBite Movie
#
# input arguments:
# movInfo      - (dict) data to make movie (generated by matlab)
# saveToFolder - (string) path to folder where finished movies are saved
#
#############################################################################
def makeHoldBiteMovie(movInfo, saveToFolder, frontWindow=None, sideWindow=None, codec='MJPG',ext='.avi'):
    plt.close('all')
    if frontWindow==None:
        try:
            frontWindow = tuple(movInfo['FrontMovie']['Window'])
        except:
            frontWindow = (0, 0, 160, 120)
    if sideWindow==None:
        try:
            sideWindow = tuple(movInfo['SideMovie']['Window'])
        except:
            sideWindow = (0, 0, 160, 120)
            
    baseName = os.path.basename(movInfo['SessionFile'])
    sessionStr, jext = os.path.splitext(baseName)
    fullMovPath = os.path.join(saveToFolder, sessionStr + ext)
    print('Save to:', fullMovPath)

    hasFront = len(movInfo['FrontMovie']['Folder'])>0
    hasSide = len(movInfo['SideMovie']['Folder'])>0
    hasLog = len(movInfo['BiteTraces']['LogFile'])>0

    if hasFront and hasSide:
        numVids = 2
    elif hasFront ^ hasSide: # either but not both
        numVids = 1
    else:
        numVids = 0

    plotHeight = 480
    plotWidth = 640
    him = 0
    wim = 0
    if numVids > 0:
        him = 240
        wim = 320

    (hf, wf) = (plotHeight+him, plotWidth)

    outputFrame = np.zeros((hf, wf, 3)).astype(np.uint8)
    plotIm = np.zeros((480, 640, 3)).astype(np.uint8)

    timestampPos = (10, 10)
    bitePos = ()

    fontSize = 20
    axLabelFontSize = 15
    axLabelFontName = 'DejaVu Sans'
    font = {'family' : 'sans-serif',
            'weight' : 'light',
            'size'   : 18}

    mpl.rc('font', **font)
    font = ImageFont.truetype(os.path.join(Path().absolute(), 'Roboto', 'Roboto-Black.ttf'), fontSize)
    timestampCol = (255, 255, 255)
    biteCol = 'forestgreen'
    waterCol = 'darkturquoise'
    timeoutCol = 'crimson'

    # initialize the FourCC, video writer, dimensions of the frame, and
    fourcc = cv2.VideoWriter_fourcc(*codec)
    writer = cv2.VideoWriter(fullMovPath, fourcc, movInfo['FrameRate'], (wf, hf))
    print('Writer size:', wf, hf)

    # make plots
    plotFig, ax = plt.subplots(3,1)#,dpi=200, figsize=(640/200, 480/200))
    canvas = FigureCanvas(plotFig)
    bbox = plotFig.get_window_extent().transformed(plotFig.dpi_scale_trans.inverted())
    width, height = bbox.width, bbox.height
    width *= plotFig.dpi
    height *= plotFig.dpi

    windAx = ax[0]
    fullAx = ax[1]
    avgAx = ax[2]

    windAx.tick_params(bottom=False, left=False)
    fullAx.tick_params(bottom=False, left=False)
    avgAx.tick_params(bottom=False, left=False)
    windAx.set_frame_on(False)
    fullAx.set_frame_on(False)
    avgAx.set_frame_on(False)

    windowSize = 20
    biteWindow = 1

    allBiteTimes = movInfo['AllBiteTimes']
    try:
        allBiteDurs = allBiteTimes[:,1] - allBiteTimes[:,0]
    except:
        allBiteDurs = allBiteTimes[1] - allBiteTimes[0]
        allBiteDurs = np.expand_dims(allBiteDurs, axis=0)
        allBiteDurs = allBiteTimes[:,1] - allBiteTimes[:,0]

    avgBiteDur = movmean(allBiteDurs, windowSize)
    rewardTimes = movInfo['RewardTimes']
    if len(rewardTimes.shape)<2:
        rewardTimes = np.expand_dims(rewardTimes, axis=0)
    rewardTimes = np.array(rewardTimes)

    timeoutTimes = movInfo['TimeoutTimes']
    if len(timeoutTimes.shape)<2:
        timeoutTimes = np.expand_dims(timeoutTimes, axis=0)
    timeoutTimes = np.array(timeoutTimes)
    avgAx.set_xlabel('Time (s)', fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    avgAx.set_ylabel('Avg Duration (s)', fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    avgAx.set_xlim(0, movInfo['SessionDuration'])
#

    fullAx.set_ylim(-0.1, 3.1)
    fullAx.set_xlim(0, movInfo['SessionDuration'])
    fullAx.set_yticks([0.5, 1.5, 2.5])
    fullAx.set_yticklabels(['Timeout', 'Water', 'Biting'], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    fullAx.set_xticks([])
    fullAx.set_xticklabels([])

    windAx.set_title(' '.join([movInfo['Subject'], 'HoldTime: %03d ms on' % movInfo['HoldTime'], movInfo['DateString'], 'at', movInfo['TimeString']]))
    windAx.set_ylim(-0.1, 3.1)
    windAx.set_xlim(0, biteWindow)
    windAx.set_yticks([0.5, 1.5, 2.5])
    windAx.set_yticklabels(['Timeout', 'Water', 'Biting'], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')


    biteDurLine = avgAx.plot(allBiteTimes[:,0], avgBiteDur, color='royalblue',
                             linewidth=1, label='Avg Bite Duration (last %d bites)' % windowSize)

    avgAxYLim = avgAx.get_ylim()
    numBites = len(avgBiteDur)
    numRewards = len(avgBiteDur)
    numTimeouts = len(avgBiteDur)

    biteBoxes = []
    timeoutBoxes = []
    waterBoxes = []

    #bite boxes
    for bite in range(numBites):
        biteOn = allBiteTimes[bite,0]
        biteOff = allBiteTimes[bite,1]
        biteDur = biteOff - biteOn
        rect = Rectangle((biteOn,2.1), biteDur, 0.8)
        biteBoxes.append(rect)

    #water boxes
    for reward in rewardTimes:
        rewardOn = reward[0]
        rewardOff = reward[1]
        rewardDur = rewardOff - rewardOn
        rect = Rectangle((rewardOn,1.1), rewardDur, 0.8)
        waterBoxes.append(rect)

    #timeout boxes
    for timeout in timeoutTimes:
        timeoutOn = timeout[0]
        timeoutOff = timeout[1]

        timeoutDur = timeoutOff - timeoutOn
        rect = Rectangle((timeoutOn,0.1), timeoutDur, 0.8)
        timeoutBoxes.append(rect)

    biteCollectionFull = PatchCollection(biteBoxes, facecolor=biteCol, edgecolor='None')
    biteCollectionWind = PatchCollection(biteBoxes, facecolor=biteCol, edgecolor='None')

    waterCollectionFull = PatchCollection(waterBoxes, facecolor=waterCol, edgecolor='None')
    waterCollectionWind = PatchCollection(waterBoxes, facecolor=waterCol, edgecolor='None')

    timeoutCollectionFull = PatchCollection(timeoutBoxes, facecolor=timeoutCol, edgecolor='None')
    timeoutCollectionWind = PatchCollection(timeoutBoxes, facecolor=timeoutCol, edgecolor='None')



    # Add collection to axes
    windAx.add_collection(biteCollectionWind)
    fullAx.add_collection(biteCollectionFull)
    windAx.add_collection(waterCollectionWind)
    fullAx.add_collection(waterCollectionFull)
    windAx.add_collection(timeoutCollectionWind)
    fullAx.add_collection(timeoutCollectionFull)

    if hasLog:
        fullAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Analog']+2, linewidth=0.5, color='gold')
        fullAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Digital']+2, linewidth=0.5, color='mediumpurple')
        windAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Analog']+2, linewidth=2, color='gold', label='Sensor')
        windAx.plot(movInfo['BiteTraces']['Timestamps'], movInfo['BiteTraces']['Digital']+2, linewidth=2, color='mediumpurple', label='Bpod')
        windAx.legend( loc='lower right')



    plotFig.set_size_inches( 640/plotFig.dpi, 480/plotFig.dpi)

    canvas.draw()

    labels = avgAx.get_xticklabels(which='major')
    labs = [label.get_text() for label in labels]
    avgAx.set_xticklabels(labs, fontsize=axLabelFontSize, fontweight=1)

    windAx.set_xlim(-0.1, biteWindow+0.1)
#     wl = avgAx.get_xticklabels(which='major')
#     windAx.set_xticklabels([label.get_text() for label in wl], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')
    lastBiteIdx = 0


    for fidx, frameTime in enumerate(movInfo['FrameTimes']):
        windAx.set_xlim(frameTime-0.1, frameTime+biteWindow+0.1)
#         wl = avgAx.get_xticklabels(which='major')
#         windAx.set_xticklabels([label.get_text() for label in wl], fontsize=axLabelFontSize, fontname=axLabelFontName, fontweight='light')

        fullRect = Rectangle((frameTime,0), biteWindow, 3, fill=None, edgecolor='k', linewidth=2)
        fullAx.add_patch(fullRect)

        windRect = Rectangle((frameTime,0), biteWindow, 3, fill=None, edgecolor='k', linewidth=2)
        windAx.add_patch(windRect)
        bdl = '%03d ms' %int(1000*avgBiteDur[lastBiteIdx])
        avl = avgAx.plot([frameTime, frameTime], [0, 1], color='red',linewidth=2,label=bdl)
        avgAx.set_ylim(avgAxYLim)
        avleg = avgAx.legend(loc='lower right', fontsize=axLabelFontSize-2)
        if allBiteTimes[lastBiteIdx,0]<=frameTime:
            if lastBiteIdx<len(allBiteTimes[:,0])-1:
                lastBiteIdx += 1

        canvas.draw()       # draw the canvas, cache the renderer

        s, (width, height) = canvas.print_to_buffer()
        plotIm = np.fromstring(canvas.tostring_rgb(), dtype='uint8').reshape(height, width, 3)
        avl[0].remove()
        fullRect.remove()
        windRect.remove()
        del avl
        avleg.remove()
        #plotImArr = np.array(plotFig.canvas.renderer.buffer_rgba())
        if fidx==0:
            plt.figure()
            plt.imshow(plotIm)

        #plotIm = np.array(plotImObj)

        if numVids==0:
            outputFrame[:, :, 0] = plotIm[:, :, 2]
            outputFrame[:, :, 1] = plotIm[:, :, 1]
            outputFrame[:, :, 2] = plotIm[:, :, 0]
        else:

            if not hasFront:
                frontIm = Image.new('RGB', (wim, him))
                drawObjF = ImageDraw.Draw(frontIm)
            else:
                imfPath = os.path.join(movInfo['FrontMovie']['Folder'],
                                      movInfo['FrontMovie']['ImageNames'][fidx])
                imfGray = Image.open(imfPath)
                imfGray = imfGray.crop(frontWindow)
                imfGray = imfGray.rotate(180)
                imfGray = imfGray.resize((wim, him))
                frontIm = imfGray.convert('RGB')
                drawObjF = ImageDraw.Draw(frontIm)

                #draw timestamp
                ftf = movInfo['FrontMovie']['Timestamps'][fidx]
                ftfStr = formatTimeStr(ftf)
                textWidth, textHeight = drawObjF.textsize(ftfStr, font=font)
                timestampPos = (wim-textWidth, 0)
                drawObjF.text(timestampPos, ftfStr, fill=timestampCol, font=font)

            if not hasSide:
                sideIm = Image.new('RGB', (wim, him))
                drawObjS = ImageDraw.Draw(sideIm)
            else:
                imsPath = os.path.join(movInfo['SideMovie']['Folder'],
                                      movInfo['SideMovie']['ImageNames'][fidx])
                imsGray = Image.open(imsPath)
                imsGray = imsGray.crop(sideWindow)
                imsGray = imsGray.rotate(180)
                imsGray = imsGray.resize((wim, him))
                sideIm = imsGray.convert('RGB')
                drawObjS = ImageDraw.Draw(sideIm)

                #draw timestamp
                fts = movInfo['SideMovie']['Timestamps'][fidx]
                ftsStr = formatTimeStr(fts)
                textWidth, textHeight = drawObjS.textsize(ftsStr, font=font)
                timestampPos = (wim - textWidth, 0)
                drawObjS.text(timestampPos, ftsStr, fill=timestampCol, font=font)

            #draw biting/water
            biting = movInfo['BiteFrames'][fidx]
            deliveringReward = movInfo['WaterFrames'][fidx]
            if biting:
                    drawObjF.text((0, 0), 'BITING', fill=biteCol, font=font)
            if deliveringReward:
                    drawObjF.text((0, fontSize+1), 'WATER', fil=waterCol, font=font)

            frontOut = np.array(frontIm).astype(np.uint8)
            sideOut = np.array(sideIm).astype(np.uint8)
            outputFrame[him:hf, :, 0] = plotIm[:, :, 2]
            outputFrame[him:hf, :, 1] = plotIm[:, :, 1]
            outputFrame[him:hf, :, 2] = plotIm[:, :, 0]
            outputFrame[0:him, 0:wim, :] = frontOut
            outputFrame[0:him, wim:wf, :] = sideOut

        cv2.imshow("OutputFrame", outputFrame)
        writer.write(outputFrame)
        # show the frames
        key = cv2.waitKey(30)
        # if the `q` key was pressed, break from the loop
        if key == 27:
            break

    # do a bit of cleanup
    print("[INFO] cleaning up...")
    cv2.destroyAllWindows()
    writer.release()
